<?php


namespace Kodilab\Deployer\Tests\Unit\Git\Diff\Entries;


use Illuminate\Support\Str;
use Kodilab\Deployer\Changes\Add;
use Kodilab\Deployer\Changes\ChangeList\ChangeList;
use Kodilab\Deployer\Changes\Delete;
use Kodilab\Deployer\Changes\Modify;
use Kodilab\Deployer\Configuration\Configuration;
use Kodilab\Deployer\Exceptions\ChangeIncoherenceException;
use Kodilab\Deployer\Helpers\Path;
use Kodilab\Deployer\Tests\TestCase;

class ChangeListTest extends TestCase
{
    /**
     * @var ChangeList
     */
    protected $collection;

    /**
     * @throws \Exception
     */
    protected function setUp()
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $this->collection = new ChangeList(new Configuration(require __DIR__ .'/../../../config/config.php'), self::LARAVEL_PROJECT);
    }

    public function test_add_change_should_not_include_recursively_more_files_if_it_is_a_file()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file1 = Path::build($directory, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);
        $this->filesystem->makeDirectory(dirname($file2), 0755, true);

        file_put_contents($file1, '');
        file_put_contents($file2, '');
        $this->collection->add(new Add(Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), false));

        $this->assertEquals(1, count($this->collection->getChanges()));
        $this->assertEmpty($this->collection->getChanges()->where('path', Str::after($file1, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_add_change_should_include_all_file_is_it_is_directory()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file1 = Path::build($directory, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);
        $this->filesystem->makeDirectory(dirname($file2), 0755, true);

        file_put_contents($file1, '');
        file_put_contents($file2, '');
        $this->collection->add(new Add(Str::after($directory, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), true));

        $this->assertEquals(2, count($this->collection->getChanges()));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file1, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_modify_change_should_not_include_recursively_more_files_if_it_is_a_file()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file1 = Path::build($directory, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);
        $this->filesystem->makeDirectory(dirname($file2), 0755, true);

        file_put_contents($file1, '');
        file_put_contents($file2, '');
        $this->collection->add(new Modify(Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), false));

        $this->assertEquals(1, count($this->collection->getChanges()));
        $this->assertEmpty($this->collection->getChanges()->where('path', Str::after($file1, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_modify_change_should_include_all_file_is_it_is_directory()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file1 = Path::build($directory, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);
        $this->filesystem->makeDirectory(dirname($file2), 0755, true);

        file_put_contents($file1, '');
        file_put_contents($file2, '');
        $this->collection->add(new Modify(Str::after($directory, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), true));

        $this->assertEquals(2, count($this->collection->getChanges()));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file1, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_delete_change_should_delete_recursively_if_its_parent_is_empty()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);
        $this->filesystem->makeDirectory(dirname($file2), 0755, true);

        $this->collection->add(new Delete(Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), false));

        $this->assertEquals(1, count($this->collection->getChanges()));
        $this->assertEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($directory, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_delete_change_should_delete_recursively_if_its_parent_does_not_exist()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word, $this->faker->word);

        $this->collection->add(new Delete(Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), false));

        $this->assertEquals(1, count($this->collection->getChanges()));
        $this->assertEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($directory, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_delete_change_should_not_delete_recursively_if_its_parent_is_not_empty()
    {
        $directory = Path::build(self::LARAVEL_PROJECT, $this->faker->word);
        $file1 = Path::build($directory, $this->faker->word);
        $file2 = Path::build($directory, $this->faker->word);

        $this->filesystem->makeDirectory(dirname($file2), 0755, true);
        file_put_contents($file1, '');

        $this->collection->add(new Delete(Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR), false));

        $this->assertEquals(1, count($this->collection->getChanges()));
        $this->assertNotEmpty($this->collection->getChanges()->where('path', Str::after($file2, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
        $this->assertEmpty($this->collection->getChanges()->where('path', Str::after($directory, self::LARAVEL_PROJECT . DIRECTORY_SEPARATOR)));
    }

    public function test_add_entry_should_throw_an_exception_if_already_an_entry_exists_with_the_same_path()
    {
        $this->expectException(ChangeIncoherenceException::class);

        $entry = new Add($this->faker->name);
        $entry2 = new Modify($entry->getPath());

        $this->collection->add($entry);
        $this->collection->add($entry2);
    }

    public function test_add_entry_should_not_throw_an_exception_if_already_an_entry_exists_with_the_same_path_and_same_change()
    {
        $entry = new Add($this->faker->name);
        $entry2 = new Add($entry->getPath());

        $this->collection->add($entry);
        $this->collection->add($entry2);

        $this->assertEquals(1, count($this->collection->getChanges()));
    }

    public function test_add_ignored_entry_should_not_be_added_in_the_changes_list()
    {
        $changeList = new ChangeList(new Configuration(['ignore' => ['a/*'], 'manager' => ['protocol' => 'simulate']]), self::LARAVEL_PROJECT);

        $add = new Add('a/b');

        $changeList->add($add);

        $this->assertTrue($changeList->getChanges()->where('path', $add->getPath())->isEmpty());
        $this->assertEquals($add, $changeList->getIgnored()->where('path', $add->getPath())->first());
    }
}
